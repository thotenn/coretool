import logging

from django.db import connection, models
# from django.db.backends.oracle.base import DatabaseWrapper as OracleDatabaseWrapper
from django.db.backends.sqlite3.base import DatabaseWrapper as SQLiteDatabaseWrapper
from django.db.backends.postgresql.base import DatabaseWrapper as PostgresqlDatabaseWraper
# from django.db.backends.postgresql_psycopg2.base import DatabaseWrapper as PostgresqlPsycopg2DatabaseWraper  # No soportado mas para las versiones < 3

logger = logging.getLogger(__name__)  # pylint: disable=invalid-name

SEQUENCE_DEFAULT_INITIAL_VALUE = 10000


class BaseDeDatosNoSoportado(Exception):
    def __init__(self, tipo_base_de_datos):
        super().__init__('Este campo no soporta para la base de datos de tipo {tipo_base_de_datos}.'.format(
            tipo_base_de_datos=tipo_base_de_datos))


class ReservableAutoField(models.AutoField):
    """
    Campo de entero autoincremental similar a models.AutoField
    de django pero inicializa la secuencia desde el valor
    especificado en initial_value. Por defecto, se inicializa
    con el valor especificado en SEQUENCE_DEFAULT_INITIAL_VALUE.

    Debido a la heterogeneidad de SQL en la manipulación de
    secuencias entre las distintas base de datos, la manera
    como se maneja estas secuencias están divididas en el
    método db_type() y corregir_secuencia().
    """

    def __init__(self, *args, initial_value=SEQUENCE_DEFAULT_INITIAL_VALUE, **kwargs):
        self.initial_value = initial_value
        super().__init__(*args, **kwargs)

    def db_type(self, connection):
        """
        Retorna la definición del tipo de dato del campo
        entero autoincremental.

        Uno de los momentos en donde este método es utilizado es
        durante la migración. En particular, este método es invocado
        cuando se crea una tabla.

        Para Oracle:
            Django originalmente utiliza el tipo de dato

                NUMBER(11) GENERATED BY DEFAULT ON NULL AS IDENTITY

            (véase DatabaseWrapper.data_types del django.db.backends.oracle.base).
            Con la nueva definición

                NUMBER(11) GENERATED BY DEFAULT ON NULL AS IDENTITY(START with <valor_inicial> INCREMENT by 1)

            fuerza a que inicie la secuencia desde el valor especificado
            en <valor_inicial>.
        Para SQLite:
            No soporta una definición de tipo de dato en donde se pueda
            especifcar el valor inicial de la secuencia. Por lo tanto, se
            utiliza por defecto el tipo de dato

                integer

            y la secuencia se manipula en corregir_secuencia().

        Para otras bases de datos:
            Implementar la definición cuando se necesite. Tome como referencia
            las implementaciones de django ubicados en el módulo python
            django.db.backends.<nombre>.base en donde <nombre> es el nombre de
            la base de datos (ejemplo: mysql, postgresql).
        """
        # if connection.vendor == OracleDatabaseWrapper.vendor:
        #     return 'NUMBER(11) GENERATED BY DEFAULT ON NULL AS IDENTITY(START with %d INCREMENT by 1)' % self.initial_value
        if connection.vendor == SQLiteDatabaseWrapper.vendor:
            return 'integer'
        # elif connection.vendor in [PostgresqlDatabaseWraper.vendor, PostgresqlPsycopg2DatabaseWraper.vendor]:
        elif connection.vendor in [PostgresqlDatabaseWraper.vendor]:
            return 'serial'
        else:
            raise BaseDeDatosNoSoportado(connection.display_name)

    def corregir_secuencia(self):
        """
        Corrige la secuencia del campo entero autoincremental si
        el valor se encuentra por debajo del valor especificado
        en initial_value.

        Este método no es manejado automáticamente por django y
        debe ser invocado explícitamente. Uno de los posibles
        lugares en donde podría ser invocado es en el método
        check() de los modelos (tome como ejemplo el modelo
        ComplexModel). El método check() es invocado durante la
        inicialización de django (si no está deshabilitado).

        Para Oracle:
            Con la definición del db_type() es suficiente.
        Para SQLite:
            En caso que el valor de la secuencia es menor a
            initial_value, asigna a la secuencia el valor

                max(initial_value, maximo valor de la columna o 0 si no hay un máximo)

        Para otras bases de datos:
            Implementar la definición cuando se necesite.
        """

        table_name = self.model._meta.db_table

        if self.aplica_correcion():
            # if connection.vendor == OracleDatabaseWrapper.vendor:
            #     # Notas en caso que se necesite asignar un valor.
            #
            #     # Para obtener el nombre de la secuencia:
            #     # SELECT SEQUENCE_NAME FROM ALL_TAB_IDENTITY_COLS WHERE TABLE_NAME = '<tabla>' and COLUMN_NAME = '<columna>';
            #
            #     # Para obtener el valor actual de la secuencia (la columna LAST_NUMBER de la tabla all_sequences no da el valor exacto):
            #     # ALTER TABLE <tabla> MODIFY id GENERATED BY DEFAULT ON NULL AS IDENTITY(INCREMENT by 1);
            #     # SELECT <secuencia>.nextval S FROM dual;
            #     # ALTER TABLE <tabla> MODIFY id GENERATED BY DEFAULT ON NULL AS IDENTITY(INCREMENT by -1);
            #     # SELECT <secuencia>.nextval S FROM dual;
            #     # ALTER TABLE <tabla> MODIFY id GENERATED BY DEFAULT ON NULL AS IDENTITY(INCREMENT by 1);
            #
            #     # Para alterar el valor de la secuencia:
            #     # ALTER TABLE <tabla> MODIFY id GENERATED BY DEFAULT ON NULL AS IDENTITY(INCREMENT by <incremento>);
            #     # SELECT <secuencia>.nextval S FROM dual;
            #     # ALTER TABLE <tabla> MODIFY id GENERATED BY DEFAULT ON NULL AS IDENTITY(INCREMENT by 1);
            #
            #     pass
            if connection.vendor == SQLiteDatabaseWrapper.vendor:
                with connection.cursor() as cursor:
                    # Obtiene el valor actual de la secuencia
                    cursor.execute('SELECT seq FROM SQLITE_SEQUENCE WHERE name=%s;', [
                        table_name.lower()])
                    seq = cursor.fetchone()[0]
                    # Si el valor de la secuencia es menor al valor inicial,
                    if seq < self.initial_value:
                        # Obtiene el valor máximo de la columna (0 en caso de NULL)
                        cursor.execute('SELECT MAX(%s) from %s;' %
                                       (self.column, table_name.lower()))
                        max_id = cursor.fetchone()[0] or 0
                        # Asigna el valor máxmimo entre el initial_value y el máximo
                        # valor existente en la columna.
                        sequence_set_value = max(self.initial_value, max_id)
                        cursor.execute('UPDATE SQLITE_SEQUENCE SET seq = %s WHERE name = %s;', [
                            sequence_set_value, table_name.lower()])
                        logger.info('El valor de la secuencia de la tabla %s fue actualizado a %d',
                                    table_name.lower(), sequence_set_value)
            # elif connection.vendor in [PostgresqlDatabaseWraper.vendor, PostgresqlPsycopg2DatabaseWraper.vendor]:
            elif connection.vendor in [PostgresqlDatabaseWraper.vendor]:
                pass
            else:
                raise BaseDeDatosNoSoportado(connection.display_name)

    def aplica_correcion(self):
        """
        Decide si se aplica o no la corrección de secuencia.
        """
        # No se aplica si es el modelo es proxy.
        if self.model._meta.proxy:
            return False

        # No se aplica si la tabla del modelo no existe en la base de datos
        if self.model._meta.db_table not in connection.introspection.table_names():
            return False

        # No se aplica si la secuencia no existe
        with connection.cursor() as cursor:
            # if connection.vendor == OracleDatabaseWrapper.vendor:
            #     # # (No se necesita verificar la existencia porque no se aplica ninguna corrección)
            #     # # (En caso que se necesite, se podría hacer de la siguiente manera:)
            #     # cursor.execute('SELECT COUNT(SEQUENCE_NAME) FROM ALL_TAB_IDENTITY_COLS WHERE TABLE_NAME = %s AND COLUMN_NAME = %s;',
            #     #                [self.model._meta.db_table.upper(), self.column.upper()])
            #     # sequence = cursor.fetchone()[0]
            #     # if sequence <= 0:
            #     #     return False
            #     pass
            if connection.vendor == SQLiteDatabaseWrapper.vendor:
                cursor.execute('SELECT COUNT(name) FROM SQLITE_SEQUENCE WHERE name=%s;',
                               [self.model._meta.db_table.lower()])
                sequence = cursor.fetchone()[0]
                if sequence <= 0:
                    return False
            # elif connection.vendor in [PostgresqlDatabaseWraper.vendor, PostgresqlPsycopg2DatabaseWraper.vendor]:
            elif connection.vendor in [PostgresqlDatabaseWraper.vendor]:
                pass
            else:
                raise BaseDeDatosNoSoportado(connection.display_name)

        return True
